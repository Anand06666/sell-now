const mongoose = require('mongoose');
const Order = require('./models/Order');
const Product = require('./models/Product');
const User = require('./models/User');
require('dotenv').config();

const connectDB = async () => {
    try {
        await mongoose.connect(process.env.MONGO_URI);
        console.log('MongoDB Connected');
    } catch (error) {
        console.error('DB Connection Error:', error);
        process.exit(1);
    }
};

const debugOrder = async () => {
    await connectDB();

    try {
        const userId = '694ba926b38b03f9b7cd47fa';
        const productId = '694a3c82c1c28120ef773095';

        // 1. Find User
        const buyer = await User.findById(userId);
        if (!buyer) throw new Error('User not found');
        console.log('Buyer found:', buyer._id);

        // 2. Find Product and Update Stock
        let product = await Product.findById(productId);
        if (!product) throw new Error('Product not found');

        console.log('Product Found:', product.title, 'Current Stock:', product.stock);

        // Force update stock for testing
        product.stock = 10;
        await product.save();
        console.log('Stock updated to 10');

        // 3. Prepare Order Data (Exact User Payload)
        const orderItems = [{
            product: product._id,
            title: product.title,
            price: product.price,
            quantity: 1,
            image: product.images[0] || 'placeholder.jpg'
        }];

        const deliveryAddressPayload = {
            "name": "Xx",
            "phone": "88",
            "street": "Ddd",
            "city": "Cc",
            "state": "Dd",
            "zip": "88",
            "type": "Home"
        };

        const subtotal = product.price;
        const deliveryCharge = 40;
        const total = subtotal + deliveryCharge;

        const order = new Order({
            buyer: buyer._id,
            seller: product.seller,
            items: orderItems,
            pricing: {
                subtotal,
                deliveryCharge,
                discount: 0,
                total,
                isResellOrder: false,
                resellerPrice: 0,
                margin: 0
            },
            deliveryAddress: {
                name: deliveryAddressPayload.name,
                phone: deliveryAddressPayload.phone,
                addressLine1: deliveryAddressPayload.street,
                addressLine2: '',
                landmark: '',
                city: deliveryAddressPayload.city,
                state: deliveryAddressPayload.state,
                pincode: deliveryAddressPayload.zip,
                addressType: deliveryAddressPayload.type || 'home'
            },
            paymentMethod: {
                type: 'cod',
                status: 'pending',
                paymentResult: {}
            },
            expectedDelivery: new Date(),
            statusHistory: [{
                status: 'pending',
                timestamp: new Date(),
                note: 'Order placed'
            }]
        });

        console.log('Attempting to save order with orderNumber logic...');
        // Note: orderNumber should be generated by pre('validate') hook

        const createdOrder = await order.save();
        console.log('SUCCESS: Order created:', createdOrder.orderNumber);
        console.log('Order ID:', createdOrder._id);

    } catch (error) {
        console.error('-----------------------------');
        console.error('CREATE ORDER FAILED');
        console.error('Message:', error.message);
        console.error('Stack:', error.stack);
        if (error.errors) {
            console.error('Validation Errors:', JSON.stringify(error.errors, null, 2));
        }
        console.error('Full Error:', error);
        console.error('-----------------------------');
    } finally {
        mongoose.connection.close();
    }
};

debugOrder();
